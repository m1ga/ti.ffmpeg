/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2018 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
package ti.ffmpeg;

import com.arthenica.ffmpegkit.ExecuteCallback;
import com.arthenica.ffmpegkit.FFmpegKit;
import com.arthenica.ffmpegkit.FFmpegSession;
import com.arthenica.ffmpegkit.FFprobeKit;
import com.arthenica.ffmpegkit.LogCallback;
import com.arthenica.ffmpegkit.MediaInformationSession;
import com.arthenica.ffmpegkit.ReturnCode;
import com.arthenica.ffmpegkit.Session;
import com.arthenica.ffmpegkit.SessionState;
import com.arthenica.ffmpegkit.Statistics;
import com.arthenica.ffmpegkit.StatisticsCallback;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiFileProxy;
import org.appcelerator.titanium.io.TiBaseFile;

import java.io.IOException;

@Kroll.module(name = "TiFfmpeg", id = "ti.ffmpeg")
public class TiFfmpegModule extends KrollModule {

    private static final String LCAT = "TiFfmpegModule";
    private KrollFunction callbackSuccess;

    public TiFfmpegModule() {
        super();
    }

    @Kroll.onAppCreate
    public static void onAppCreate(TiApplication app) {
    }

    // Methods
    @Kroll.method
    public void run(KrollDict properties) throws IOException {
        TiBaseFile file = ((TiFileProxy) properties.get("input")).getBaseFile();
        final TiBaseFile file_out = ((TiFileProxy) properties.get("output")).getBaseFile();
        TiBaseFile file_watermark;
        String waterMark = "";
        if (properties.containsKeyAndNotNull("watermark")) {
            file_watermark = ((TiFileProxy) properties.get("watermark")).getBaseFile();
            waterMark = "-i " + file_watermark.nativePath();
        }
        String options = properties.getString("options");
        callbackSuccess = (KrollFunction) properties.get("success");
        final KrollFunction callbackError = (KrollFunction) properties.get("error");

        if (file != null && file_out != null) {
            FFmpegSession session = FFmpegKit.executeAsync("-i " + file.nativePath() + " " + waterMark + " " + options + " " + file_out.nativePath(), new ExecuteCallback() {

                @Override
                public void apply(Session session) {
                    SessionState state = session.getState();
                    ReturnCode returnCode = session.getReturnCode();

                    if (ReturnCode.isSuccess(session.getReturnCode())) {
                        // SUCCESS
                        MediaInformationSession infoSession = FFprobeKit.getMediaInformation(file_out.nativePath());
                        String duration = infoSession.getMediaInformation().getDuration();
                        KrollDict kd = new KrollDict();
                        kd.put("file", file_out.nativePath());
                        kd.put("duration", duration);
                        kd.put("filesize", infoSession.getMediaInformation().getSize());
                        kd.put("width", infoSession.getMediaInformation().getStreams().get(0).getWidth());
                        kd.put("height", infoSession.getMediaInformation().getStreams().get(0).getHeight());
                        callbackSuccess.call(krollObject, kd);
                    } else if (ReturnCode.isCancel(session.getReturnCode())) {

                    } else {
                        // error
                        KrollDict kd = new KrollDict();
                        kd.put("error", session.getFailStackTrace());
                        callbackError.call(krollObject, kd);
                    }
                    Log.w(LCAT, String.format("FFmpeg process exited with state %s and rc %s.%s", state, returnCode, session.getFailStackTrace()));
                }
            }, new LogCallback() {
                @Override
                public void apply(com.arthenica.ffmpegkit.Log log) {
                    // CALLED WHEN SESSION PRINTS LOGS
                }
            }, new StatisticsCallback() {
                @Override
                public void apply(Statistics statistics) {
                    KrollDict kd = new KrollDict();
                    kd.put("frame", statistics.getVideoFrameNumber());
                    kd.put("size", statistics.getSize());
                    kd.put("currentTime", statistics.getTime());
                    fireEvent("progress", kd);
                }
            });

        }
    }

    @Kroll.method
    public void info(KrollDict properties) {
        String options = properties.getString("options");

        FFmpegSession session = FFmpegKit.execute(options);
        if (ReturnCode.isSuccess(session.getReturnCode())) {
            // SUCCESS
            Log.i(LCAT, session.getOutput());
        } else if (ReturnCode.isCancel(session.getReturnCode())) {
            // CANCEL
        } else {
            // FAILURE
            Log.d(LCAT, String.format("Command failed with state %s and rc %s.%s", session.getState(), session.getReturnCode(), session.getFailStackTrace()));
        }
    }

}
